# -*- coding: utf-8 -*-
"""基于用户的协同过滤算法.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13rk1VX0tqRQebPJJ-je7tTL2G8eozSI6
"""

import sys
!{sys.executable} -m pip install pandas
!{sys.executable} -m pip install numpy

"""# 用户行为和用户-物品ui矩阵"""

import pandas as pd 
import numpy as np

evidence = pd.read_csv('collector_log.csv')

print(type(evidence))
evidence.head(5)

print(type(evidence))
evidence.head(5)
users = evidence.user_id.unique()
content = evidence.content_id.unique()
print(type(content))
print(len(content))

"""# 隐式评分
二元矩阵
从“buy”事件中创建一个用户-物品ui二元矩阵
"""

uiBuyMatrix = pd.DataFrame(columns=content, index=users)
uiBuyMatrix.head(2)

evidence.event.unique()

"""只选择"buy"事件"""

buyEvidence = evidence[evidence['event'] == 'buy']
buyEvidence.head(5)

"""给user-item buy事件创造 `uiBuyMatrix` 矩阵"""

for index, row in buyEvidence.iterrows():
    currentUser = row['user_id']
    currentContent = row['content_id']
    uiBuyMatrix.at[currentUser, currentContent] = 1

print(uiBuyMatrix)

"""## 行为隐式评分
使用以下公式

$${IR}_(i,u) = \left(w_1*{\#event}_1\right)+\left(w_2*{\#event}_2\right)+\dots+\left(w_n*{\#event}_n\right)$$
"""

uiMatrix = pd.DataFrame(columns=content, index=users)
uiMatrix.head(2)

eventTypes = evidence.event.unique()
print(eventTypes)

eventWeights = {
    'details': 15,
    'moreDetails': 50,
    'genreView': 0,
    'addToList': 0,
    'buy': 100}

"""计算每个用户-物品组合的隐式评分。使用IR值填充用户-物品矩阵uiMatrix"""

for index, row in evidence.iterrows():
 
    currentUser = row['user_id']
    currentContent = row['content_id']

    w = eventWeights[row['event']]

    currentValue = uiMatrix.at[currentUser, currentContent]
    if np.isnan(currentValue):
        currentValue = 0

    updatedValue = currentValue + w #+ (1 * w)
    uiMatrix.at[currentUser, currentContent] = updatedValue

"""# 归一化矩阵
通过将值归一化到0到10之间来更新用户-物品矩阵。

注意：NaN值应保持为NaN
"""

uiMatrixNorm = uiMatrix.apply(
    lambda x: ((x - np.nanmin(uiMatrix.values))/(np.nanmax(uiMatrix.values) - np.nanmin(uiMatrix.values)))*10
    )

uiMatrixNorm

"""# 基于用户的协同过滤

## 步骤1：计算活动用户和其他用户之间的相似度
选择一个用户。

对于需求，需要找到一个没有填满所有评分的用户
"""

uiMatrixNorm.isnull().count(axis=1)

"""在数据集中可以自由选择一个用户，条件是该用户没有评价完所有的电影"""

currentUser = 400005

uiMatrixNorm = uiMatrixNorm.astype(float)

cuDf = uiMatrixNorm.loc[currentUser]

cuDf

corrDf = uiMatrixNorm.corrwith(cuDf, axis=1, method='pearson')

corrDf.sort_values(ascending=False, inplace=True)

corrDf

corrDf.drop(labels=[currentUser], inplace=True)

corrDf = corrDf.head(2)

corrDf

toPredict = cuDf[cuDf.isna()]
toPredict

ratings = uiMatrixNorm.loc[corrDf.index]
ratings

ratingsToPredict = ratings[toPredict.index]
ratingsToPredict

"""计算当前用户的预测评分

使用其他高相似度用户的平均值
"""

predictedRatings = ratingsToPredict.mean()
predictedRatings.sort_values(ascending=False, inplace=True)
predictedRatings

"""选择前五名作为推荐"""

predictedRatings.head(5)

"""# 练习5
将上面的代码转换为函数userCF_prediction（df，currentUser，numUsers，numItems），其中参数为：

df是包含用户-物品评分的数据框
currentUser是要为其预测评分的用户
numUsers是我们要使用的用户数量来计算预测的评分
numItems是我们要返回的建议给当前用户的项目数
预测用户id 400005的前5个项目，与另外2个用户进行比较。
"""

def userCF_prediction(df, currentUser, numUsers, numItems):
    
    dfNorm = df.apply(
    lambda x: ((x - np.nanmin(df.values))/(np.nanmax(df.values) - np.nanmin(df.values)))*10
    )

    dfNorm = dfNorm.astype(float)
    cuDf = dfNorm.loc[currentUser]
    corrDf = dfNorm.corrwith(cuDf, axis=1, method='pearson')
    corrDf.sort_values(ascending=False, inplace=True)
    corrDf.drop(labels=[currentUser], inplace=True)
    corrDf = corrDf.head(numUsers)
    toPredict = cuDf[cuDf.isna()]
    ratings = dfNorm.loc[corrDf.index]
    ratingsToPredict = ratings[toPredict.index]
    predictedRatings = ratingsToPredict.mean()
    predictedRatings.sort_values(ascending=False, inplace=True)
    print(predictedRatings.head(numItems))

userCF_prediction(uiMatrix,400005,2,5)
